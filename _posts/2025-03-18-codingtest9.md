---
layout: single
title: "파이썬 - 보물 사냥꾼의 선택"
categories: coding
tag: [알고리즘, 코딩테스트, DP, Brute Force, Python]
toc: true
author_profile: false
sidebar:
  nav: "docs"
---

## 문제
한 해적단이 보물이 숨겨진 섬을 발견했다. <br>
이 섬에는 `n`개의 보물 상자가 일렬로 놓여 있으며, 각 상자에는 정해진 양의 금화가 들어 있다. <br>
하지만 **연속한 두 개의 상자**를 동시에 열면 저주가 발동하여 **모든 보물이 사라진다.**

해적단은 **인접하지 않은 두 개의 상자**를 선택하여 **가장 많은 금화**를 챙기려 합니다. <br>

### 입력 형식
첫 번째 줄에 `n`이 주어진다. <br>
두 번째 줄에 `n`개의 정수가 공백을 기준으로 주어진다. 각 정수는 해당 상자에 들어 있는 금화의 개수를 나타낸다.

### 출력 형식
해적단이 챙길 수 있는 최대 금화의 개수를 출력하라.

### 입출력 예제
입력
```
8
10 51 53 82 59 12 49 55
```
출력
```
137
```

### 예제 설명
`4`번째 수인 `82`와 `5`번째 수인 `59`를 더하면 `141`로 가장 크지만 서로 인접하기 때문에 동시에 선택할 수 없다.
그 다음으로 큰 수는 `4`번째 수인 `82` `8`번째 수인 `55`를 더하면 `137`이 되는데, 인접하지 않기 때문에 최댓값이 될 수 있다.

## 풀이법 1
```python
n = int(input())
numbers = list(map(int, input().split()))

ans = 0
for i in range(n):
    for j in range(i+2, n):
        ans = max(ans, numbers[i]+numbers[j])

print(ans)
```
1. 이중 반복문을 사용하여 두 수를 선택한다.
2. `i`는 리스트의 첫 번째 선택된 숫자의 인덱스를 나타낸다.
3. `j`는 `i+2`부터 시작하여 인접하지 않은 숫자만 선택한다.
4. `i`번째 수와 `j`번째 수의 값을 더하고 현재까지의 `ans`와 비교하여 더 큰 값을 저장한다.

## 풀이법 2
```python
n = int(input())
numbers = list(map(int, input().split()))

max_num = numbers[0]
ans = 0
for i in range(2, n):
    max_num = max(max_num, numbers[i-2])
    ans = max(max_num + numbers[i], ans)
print(ans)
```
### 풀이법 2 코드 설명
1. `max_num` : 현재까지 확인한 숫자 중에서 가장 큰 값
2. `ans` : 인접하지 않은 두 숫자의 합 중 최댓값
3. 반복문을 순회하면서 `numbers[i]`와 인접하지 않으면서 이전 값들 중 최댓값을 `max_num`에 저장한다
4. `i-1`은 인접하기 때문에 사용할 수 없으므로 `i-2`까지만 확인한다.
5. `numbers[i] + max_num`이 `ans`보다 크면 최댓값을 갱신한다.

## 풀이법 비교
1. 풀이법 1
- 이중 반복문을 사용하여 모든 가능한 인접하지 않은 숫자 쌍을 검사한다.
- `i`를 기준으로 `i+2`부터 `n-1`까지 반복하며 모든 조합을 찾아 최댓값을 찾는다.
- <code>O(n<sup>2</sup>)</code>이 걸린다.
2. 풀이법 2
- 이전까지 등장한 값 중 최댓값을 유지하면서 진행한다.
- `i-2` 위치의 값을 저장하여 `numbers[i]`와 더한 값 중 최댓값을 구한다.
- 반복문 한 번으로 <code>O(n)</code>이 걸린다.
