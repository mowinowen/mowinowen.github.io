---
layout: single
title: "파이썬 - 원형 마을의 좀비 대피소"
categories: coding
tag: [알고리즘, 코딩테스트, 누적 합, Brute Force, Python]
toc: true
author_profile: false
sidebar:
  nav: "docs"
---

## 문제
어느 날, 원형 마을에 좀비 바이러스가 퍼지기 시작했다. <br>
마을 사람들은 **N개의 집**에 살고 있으며, 시계 방향으로 집에 번호가 있다. <br>
각 집에는 일정한 수의 사람들이 거주하고 있다.

마을 사람들은 좀비로부터 안전하게 피할 수 있도록 **한 곳에 모여 대피소**를 만들어야 한다. <br>
그러나 모든 사람이 대피소까지 이동해야 하므로, 모든 사람의 **이동 거리 총합을 최소화**하는 것이 목표이다.

마을은 원형으로 되어 있고, 시계 방향으로 이동할 수 있다. 즉, N번 이동하면 원래 위치로 돌아올 수 있다.

### 입력 형식
첫 번째 줄에 `N`이 주어진다. <br>
두 번째 줄부터 `N`개의 정수가 주어지고 `i`번째 정수는 `i`번째 집에 살고 있는 사람의 수를 의미한다.

### 출력 형식
사람들이 대피소까지 이동하는 총 이동 거리의 최솟값을 출력하라.

### 입출력 예제
입력
```
5
6
7
8
2
9
```
출력
```
52
```

### 예제 설명
5번째 집에 대피소를 만든다고 가정하자.
그림

1. `5`번 집에는 `9`명이 있고 그대로 머무르면 된다. 따라서 거리의 합은 `0`이다.
2. `1`번 집에는 `6`명이 있고 `5 -> 1` 로 `1`만큼 이동해야 한다. 따라서 거리의 합은 `6`이다.
3. `2`번 집에는 `7`명이 있고 `5 -> 1 -> 2` 로 `2`만큼 이동해야 한다. 따라서 거리의 합은 `14`이다.
4. `3`번 집에는 `8`명이 있고 `5 -> 1 -> 2 -> 3` 로 `3`만큼 이동해야 한다. 따라서 거리의 합은 `24`이다.
5. `4`번 집에는 `2`명이 있고 `5 -> 1 -> 2 -> 3 -> 4` 로 `4`만큼 이동해야 한다. 따라서 거리의 합은 `8`이다.
6. 각 집에서 모든 사람들이 이동한 거리의 합은 `0 + 6 + 14 + 24 + 8 = 52` 이고 이는 최솟값이 된다.

## 풀이법 1
```python
import sys

n = int(input())
arr = [int(input()) for _ in range(n)]

sum_dist = 0
ans = sys.maxsize
for i in range(n):
    for j in range(n):
        sum_dist += arr[j] * j
    ans = min(ans, sum_dist)
    arr = arr[1:] + [arr[0]]
    sum_dist = 0

print(ans)
```
1. `sum_dist` : 현재 선택한 집을 대피소로 했을 때, 모든 사람들의 이동 거리 합
2. `ans` : 최소 이동 거리의 합을 저장.
3. 첫 번째 반복문에서 모든 집을 대피소로 가정하여 `n`번 반복.
4. 두 번째 반복문에서 `i`번째 집을 대피소로 설정했을 때, 모든 집에서 사람이 이동하는 거리를 계산.
5. 이동 거리의 합은 `j`번째 집에 있는 `arr[j]`명의 사람들이 `j`만큼 이동하여 누적하며 더함.
6. 다음 집을 대피소로 가정하기 위해 `arr`의 첫 번째 원소를 마지막으로 이동하여 배열을 회전한다.
7. `sum_dist`는 다음 계산을 위해 다시 초기화

## 풀이법 2
```python
import sys

n = int(input())
arr = [int(input()) for _ in range(n)]

sum_dist = sum(arr[i]*i for i in range(n))
ans = sum_dist
sum_arr = sum(arr)
for i in range(n-1):
    sum_dist -= sum_arr - arr[i] * n
    ans = min(sum_dist, ans)

print(ans)
```
### 아이디어
5개의 집에 각각의 사람들의 수를 리스트로 표현하면 `[a, b, c, d, e]`라고 가정하자.

예를 들어, 첫 번째 집에 대피소를 만든다면 이동 거리의 합은 `a * 0 + b * 1 + c * 2 + d * 3 + e * 4` 이다. <br>
두 번째 집에 대피소를 만든다면 이동 거리의 합은 `a * 4 + b * 0 + c * 1 + d * 2 + e * 3` 이다.

이 때, `a * 0 + b * 1 + c * 2 + d * 3 + e * 4`를 `old`, `a * 4 + b * 0 + c * 1 + d * 2 + e * 3`를 `new`라 하자. <br>
`old`에서 `new`를 빼면 `old - new = b + c + d + e - a * 4`가 된다. <br>
배열의 모든 원소를 더하면 `a + b + c + d + e` 가 되고 이를 `sum_arr`라 하자. <br>
그럼 `old - new`를 다시 정리하면 `sum_arr - a - a * 4`가 된다.

만약 리스트의 개수가 n개 라고 하고 식을 정리하면 `sum_arr - a - a * (n - 1) = sum_arr - a * n`이 된다. <br>
따라서 지금까지 설명한 것을 정리하면 다음과 같다.

<div class="notice--info">
k번째 집에 대피소를 만들고 이동 거리의 합을 old, k+1번째 집에 대피소를 만들고 이동 거리의 합을 new 라고 하면 <br>
old - new = sum_arr - n * (k번째 집에 있는 사람 수) <br>
</div>

### 풀이법 2 코드 설명
1. `sum_dist`는 1번째 집을 대피소로 했을 때의 이동 거리 합을 초기값으로 설정한다.
2. `ans`는 이동 거리의 최솟값. (초기값은 `sum_dist`)
3. `sum_arr`은 모든 집에 있는 사람의 총합
4. 반복문을 수행하면서 이전의 이동 거리 합을 이용하여 대피소로 지정한 이동 거리 합을 구한다.
5. 직전의 이동 거리 합 - (`sum_arr` - n * (k번째 집에 있는 사람 수)) 로 이동 거리 합을 갱신한다.
6. `ans`와 비교하며 최솟값을 갱신한다.

## 풀이법 비교
1. 풀이법 1
- 모든 집을 대피소로 가정하며 완전 탐색. (Brute Force)
- 이중 반복문으로 모든 집에서 이동 거리를 계산하며 <code>O(n<sup>2</sup>)</code>이 걸린다.
2. 풀이법 2
- 초기 값을 계산 후 수식으로 값을 갱신한다.
- 누적 합을 활용하여 매번 전체 합을 구하지 않아도 된다.
- 반복문 한 번으로 수행하므로 <code>O(n)</code>이 걸린다.
