---
layout: single
title: "파이썬 - 마법의 Binary 룬 문자"
categories: coding
tag: [알고리즘, 코딩테스트, 이진수, 비트연산, Python]
toc: true
author_profile: false
sidebar:
  nav: "docs"
---

## 문제
고대 마법사들은 이진수로 이루어진 신비한 룬 문자를 사용하여 주문을 기록했다. <br>
하지만 세월이 지나면서 룬 문자 중 한 글자가 마법적인 오류로 변형되었다는 사실이 밝혀졌다!

당신은 마법사로서 주어진 숫자에서 단 하나의 숫자를 바꿔 가장 강력한 숫자를 만들어야 한다. <br>
당신에게 오류로 변형된 룬 문자가 주어진다. <br>
이 룬 문자에서 한 글자만 반전시킬 수 있다. (0 -> 1, 1 -> 0) <br>
이 때 만들 수 있는 가장 강력한 숫자 (10진수)를 출력해라.

### 입력 형식
하나의 이진수가 주어지고 0과 1로만 이루어져 있다.

### 출력 형식
한 자리만 변경했을 때 얻을 수 있는 10진수 중 최댓값을 출력한다.

### 입출력 예제
입력
```
1101
```
출력
```
15
```

### 예제 설명
1101에서 각각 한자리를 변경하고 10진수로 나타내면 다음과 같다.

<ul>
  <li>0101 -> <code>2<sup>0</sup> * 1 + 2<sup>1</sup> * 0 + 2<sup>2</sup> * 1 + 2<sup>3</sup> * 0 = 5</code></li>
  <li>1001 -> <code>2<sup>0</sup> * 1 + 2<sup>1</sup> * 0 + 2<sup>2</sup> * 0 + 2<sup>3</sup> * 1 = 9</code></li>
  <li>1111 -> <code>2<sup>0</sup> * 1 + 2<sup>1</sup> * 1 + 2<sup>2</sup> * 1 + 2<sup>3</sup> * 1 = 15</code></li>
  <li>1100 -> <code>2<sup>0</sup> * 0 + 2<sup>1</sup> * 0 + 2<sup>2</sup> * 1 + 2<sup>3</sup> * 1 = 12</code></li>
</ul>

따라서 최댓값은 15이다.

## 풀이법 1
```python
binary = list(map(int, list(input())))
ans = 0

for i in range(len(binary)):
    binary[i] = 1 - binary[i]
    
    num = 0
    for j in range(len(binary)):
        num = num * 2 + binary[j]
    
    ans = max(ans, num)

    binary[i] = 1 - binary[i]

print(ans)

```
1. 입력한 이진수의 각 자리 숫자를 순회한다.
2. 이 때, 자리의 숫자가 1이면 0, 0이면 1로 변경한다.
3. 변경한 이진수를 10진수로 변환한다.
4. 변환한 10진수와 현재 최댓값을 비교하여 최댓값을 갱신한다.
5. 변경한 자리의 숫자를 원래대로 되돌려 놓는다.

## 풀이법 2
```python
binary = input()
ans = 0
for i in range(len(binary)):
    ans = max(int(binary[:i] + str(int(binary[i])^1) + binary[i+1:], 2), ans)

print(ans)
```
1. 이진수의 각 자리를 순회한다.
2. 현재 `binary`는 문자열로 받았기 때문에 `i`번째 자리의 이전과 이후는 슬라이싱을 사용하여 그대로 유지하고 `i`번째 자리의 수는 변경한다.
3. 변경할 때 XOR 연산을 사용하여 비트 반전을 해서 0 -> 1, 1 -> 0 으로 바꾼다.
4. `int(..., 2)`를 사용해서 10진수로 변경한다.

## 풀이법 3
```python
binary = input()

if '0' in binary:
  binary = binary.replace('0', '1', 1)

else:
  binary = binary[:-1] + '0'

print(int(binary, 2))
```
### 아이디어
1. 이진수에서 한 자리를 무조건 변경해서 최댓값을 찾아야한다.
2. 이진수는 2의 거듭제곱씩 0 또는 1을 곱해서 합을 계산하여 10진수를 구한다.
3. 따라서 1에서 0을 변경하면 곱하면 오히려 값이 작아지므로 0에서 1을 바꾸는 방식을 우선 생각한다.
4. 또한 2의 거듭제곱씩 증가하므로 가장 왼쪽에 있는 값이 가장 크다.
5. 따라서 이진수의 0 중에 가장 왼쪽에 있는 0을 1로 바꾸면 최댓값이 된다.
6. 하지만, 0이 없는 경우를 생각해야 한다. 모든 수가 1이면 어떠한 수를 변경해도 기존값보다 작아진다.
7. 이러한 경우에는 변경된 10진수가 기존값의 차이가 제일 작아야 한다.
8. 따라서 이진수의 가장 오른쪽에 있는 숫자 1을 0으로 바꾸면 최댓값이 된다.

### 풀이법 3 코드 설명
1. 이진수를 문자열로 입력받는다.
2. 이진수의 0이 있으면 `replace`를 사용해서 가장 앞에 있는 0을 1로 변경한다.
3. 이진수에 0이 없으면 가장 오른쪽에 있는 수를 0으로 변경한다.
4. 이진수를 10진수로 변환하여 출력한다. 

## 풀이법 비교
1. 풀이법 1
- 리스트 변환 후 모든 자리를 반전시켜 계산한다. (Brute Force)
- 모든 자리를 변경하고 이진수를 변환하는 과정이 있으며 <code>O(n<sup>2</sup>)</code>이 걸린다.
2. 풀이법 2
- 문자열을 조작하여 모든 자리를 반전시켜 계산한다.
- 모든 자리를 변경하고 이진수를 변환하는 과정이 있으며 <code>O(n<sup>2</sup>)</code>이 걸린다.
3. 풀이법 3
- 모든 경우를 탐색하지 않고 특정 규칙을 기반으로 동작한다.
- 이진수를 변환하는 과정만 있으므로 <code>O(n)</code>이 걸린다.
