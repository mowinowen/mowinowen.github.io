---
layout: single
title: "파이썬 - 최강 전사의 검검"
categories: coding
tag: [알고리즘, 코딩테스트, Brute Force, 슬라이딩 윈도우, Python]
toc: true
author_profile: false
sidebar:
  nav: "docs"
---

## 문제
어느 왕국에는 전설의 검이 숨겨진 던전이 있다. 이 던전에는 `n`개의 방이 있고, 각 방에는 마법의 힘이 깃든 수정이 있다.<br>
각 수정의 힘을 모으면 강력한 검을 만들 수 있다.

그러나 전설의 검을 만들기 위해서는 반드시 **연속된 `k`개의 방**에서 수정의 힘을 모아야 한다. <br>
연속된 `k`개의 방에서 얻을 수 있는 힘의 **최댓값**을 구해 가장 강력한 검을 만들어야 한다.

### 입력 형식
첫 번째 줄에 두 정수 `n`과 `k`가 주어진다.<br>
두 번째 줄에 n개의 정수가 공백으로 구분되어 주어진다. 각 정수는 해당 방에 있는 수정의 힘을 나타낸다.

### 출력 형식
연속된 k개의 방에서 얻을 수 있는 힘의 최대치를 구하여라.

### 입출력 예제
입력
```
8 4
-12 2 -7 33 44 -2 11 23
```
출력
```
86
```

### 예제 설명
위의 예제에서 8개의 숫자 중 4개의 연속된 합은 다음과 같다.

|index|numbers|sum|
|------|---|---|
|0~3|-12, 2, -7, 33 |16|
|1~4|-2, -7, 33, 44 |72|
|2~5|-7, 33, 44, -2 |68|
|3~6|33, 44, -2, 11 |86|
|4~7|44, -2, 11, 23 |76|

따라서 최댓값은 인덱스가 `3~6`인 `86`이다.

## 풀이법 1
```python
n, k = map(int, input().split())
arr = list(map(int, input().split()))

ans = float('-inf')
for i in range(n-k+1):
    sum_val = 0
    for j in range(i, i+k):
        sum_val += arr[j]
    
    ans = max(ans, sum_val)

print(ans)

```
1. `ans` : 최댓값을 저장할 변수. 초기값을 매우 작은 값으로 설정
2. 이중 반복문을 통해 연속된 k개의 방을 선택한다.
  - `i` : 시작 방의 위치. 마지막 시작 위치는 `n-k`
  - `sum_val` : 현재 선택한 k개의 방의 힘의 합.
  - `j` : `i`번째 방부터 `i+k-1`번째 방까지의 힘을 더한다.
3. `ans`와 `sum_val`을 비교해서 더 큰 값을 `ans`에 저장한다.


## 풀이법 2
```python
n, k = map(int, input().split())
arr = list(map(int, input().split()))

ans = prefix_sum = sum(arr[:k])
for i in range(1, n-k+1):
    ans = max(ans, prefix_sum := prefix_sum - arr[i-1] + arr[i+k-1])
print(ans)
```
1. 처음 `k`개의 요소를 더하여 초기 부분합 `prefix_sum`을 구한다.
2. 현재까지의 최대 힘을 `ans`에 저장한다.
3. 슬라이딩 윈도우 기법 적용
  - 윈도우를 오른쪽으로 한 칸씩 이동하며 최대 합을 찾는다.
  - 현재 윈도우에서 제외되는 값 `arr[i-1]`을 빼고, 새롭게 포함되는 값 `arr[i+k-1]`을 더한다.
  - `ans`와 `prefix_sum`을 비교해서 더 큰 값을 `ans`에 저장한다.


## 풀이법 비교
### 풀이법 1
- 완전 탐색 (Brute Force) 사용
- 가능한 모든 구간을 하나씩 탐색하면서 합을 계산.
- 시작 위치를 기준으로 `k`개의 값을 직접 더해 최대값을 갱신.
- 바깥 루프 <code>O(N)</code>, 안쪽 루프 <code>O(K)</code>, 총 <code>O(NK)</code>이 걸린다.

### 풀이법 2
- 슬라이딩 윈도우 사용.
- 초기 윈도우(`k`개의 합)를 먼저 계산 후 윈도우를 한 칸씩 이동하면서 빠지는 값 빼고, 새로 들어오는 값 더하기.
- <code>O(N)</code>이 걸린다.