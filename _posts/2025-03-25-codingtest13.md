---
layout: single
title: "파이썬 - 외계인이 보내온 메시지"
categories: coding
tag: [알고리즘, 코딩테스트, Brute Force, Python]
toc: true
author_profile: false
sidebar:
  nav: "docs"
---

## 문제
NASA는 최근 우주에서 수신된 **N × M** 크기의 신비로운 메시지를 발견했다. <br>
이 메시지는 **알파벳 대문자**로 이루어진 격자판 형태이며, 그 속에는 외계인의 암호 단어가 숨겨져 있다!

당신은 격자판에서 외계인의 암호 단어가 **몇 번 등장**하는지 찾아내야 한다.

특정한 단어가 가로, 세로, 대각선 방향으로 연속된 칸을 따라 존재하는 경우의 수를 구하라.

### 입력 형식
첫 번째 줄에 두 정수 `N`, `M`이 주어진다. <br>
이후 N개의 줄에 걸쳐 M개의 문자로 이루어진 외계 메시지가 주어진다. <br>
마지막 줄에 찾아야 할 외계 암호 단어가 주어진다.

### 출력 형식
메시지에서 암호 단어가 등장하는 모든 경우의 수를 출력한다.


### 입출력 예제
입력
```
3 4
EEMO
MOME
OMEO
OME
```
출력
```
5
```

### 예제 설명
제시한 단어인 `OME`는 다음과 같은 위치에 있다.

1. (0, 3) -> (0, 2) -> (0, 1) (←)
2. (1, 1) -> (1, 2) -> (1, 3) (→)
3. (2, 0) -> (1, 0) -> (0, 0) (↑)
4. (2, 0) -> (2, 1) -> (2, 2) (→)
5. (2, 3) -> (1, 2) -> (0, 1) (↖)

따라서 5가지의 경우의 수가 존재한다.

## 풀이법 1
```python
N, M = map(int, input().split())
arr = [input() for _ in range(N)]

word = input()
word_len = len(word)
directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, -1), (1, 1), (-1, 1), (-1, -1)]
ans = 0
for i in range(N):
    for j in range(M):
        for x, y in directions:
            if arr[i][j] == word[0] and 0 <= i+(word_len-1)*x < N and 0 <= j+(word_len-1)*y < M:
                isbool = True
                for k in range(1, word_len):
                    if arr[i+k*x][j+k*y] != word[k]:
                        isbool = False
                if isbool:
                    ans += 1

print(ans)
```

1. 격자에서 단어를 찾을 수 있는 8가지 방향을 정의한다.
- `(0, 1)`: 오른쪽(→)
- `(0, -1)`: 왼쪽(←)
- `(1, 0)`: 아래쪽(↓)
- `(-1, 0)`: 위쪽(↑)
- `(1, -1)`: 대각선 왼쪽 아래(↙)
- `(1, 1)`: 대각선 오른쪽 아래(↘)
- `(-1, 1)`: 대각선 오른쪽 위(↗)
- `(-1, -1)`: 대각선 왼쪽 위(↖)
2. 이중 반복문을 통해 모든 행과 열을 탐색하고 8가지 방향으로 단어가 있는지 탐색한다.
3. 찾는 단어가 격자 안에 있는 단어인지 확인한다.
- 현재 위치인 `(i, j)`가 단어의 첫 글자와 같은지 확인한다.
- 단어의 마지막 글자가 격자 범위 내에 있는지 확인한다.
- 격자 범위에 벗어나면 방향은 탐색하지 않는다.
4. 단어의 두 번째 글자부터 비교하여 하나라도 다르면 중단한다.
5. 만약 모든 글자가 일치한다면 답의 개수를 증가한다.

## 풀이법 2
```python
N, M = map(int, input().split())
arr = [input() for _ in range(N)]

word = input()
word_len = len(word)
directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, -1), (1, 1), (-1, 1), (-1, -1)]
ans = 0

first_word_idxs = [(i, j) for i in range(N) for j in range(M) if arr[i][j] == word[0]]

for i, j in first_word_idxs:
    for x, y in directions:
        nx, ny = i + (word_len - 1) * x, j + (word_len - 1) * y
        
        if 0 <= nx < N and 0 <= ny < M:
            if all(arr[i + x * k][j + y * k] == word[k] for k in range(1, word_len)):
                ans += 1

print(ans)
```

1. 격자판에서 단어의 첫 글자와 같은 문자가 있는 위치 `(i, j)`를 `first_word_idxs`에 저장한다.
2. 단어의 첫 글자가 있는 모든 위치에서 단어를 찾는다.
3. 단어가 격자 범위 안에 있는지 확인한다.
4. `all()`을 사용해서 모든 글자가 일치하는지 확인한다. -> 만약 하나라도 다르면 `False`를 반환할 것이다.

## 풀이법 비교
### 풀이법 1
- 모든 격자 칸에서 첫 글자 탐색하여 연산량이 많다.
- 첫 글자가 일치하지 않아도 8방향을 계속 검사하여 불필요한 연산이 많다.
- 조건문과 반복문 사용으로 비교 연산이 많다.
- 연산량은 `(N × M) × 8 × 단어 길이`이다.

### 풀이법 2
- 첫 글자가 있는 위치를 미리 저장하여 탐색 범위를 축소한다.
- `all()` 함수를 사용해 비교 연산을 간결하게 처리한다.
- 연산량은 `(첫 글자 개수) × 8 × 단어 길이`이다.
- 필요 없는 연산을 줄여 성능을 개선한다.