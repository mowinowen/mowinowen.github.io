---
layout: single
title: "파이썬 - 드론 고도 안정화"
categories: coding
tag: [Python, 알고리즘, 코딩테스트, Brute Force, 슬라이딩 윈도우]
toc: true
author_profile: false
sidebar:
  nav: "docs"
---

## 문제
도시의 정찰 드론들은 일정한 고도에서 비행해야 한다. 하지만 바람, 건물, 기류 등의 영향으로 고도 유지에 어려움이 있다. <br>
도시 방위국은 드론들이 비행 중인 구간에서 가장 안정적으로 고도를 유지할 수 있는 **비용이 가장 적은 구간**을 분석하려 한다.

각 드론의 고도는 시시각각 변하며, 드론들은 총 `n`개의 시간 구간 동안 고도를 기록했다. <br> 
이상적인 고도는 `h`이며, 당신은 연속된 `t`개의 시간 구간을 선택해 드론의 고도를 `h`로 맞추는 데 드는 **최소 비용**을 계산해야 한다.

**고도 조정 비용**은 해당 시간 구간의 고도와 h의 차이의 절댓값의 합이다.

### 입력 형식
첫 번째 줄에 세 정수 `n, h, t`를 입력한다. <br>
두 번째 줄에 `n`개의 정수가 주어진다. 각 수는 시간 구간별 드론의 고도이다. <br>

### 출력 형식
연속된 `t`개의 시간 구간 중 드론 고도를 `h`로 맞추는 데 드는 최소 조정 비용을 출력하라.

### 입출력 예제
입력
```
8 50 3
90 61 36 72 55 90 15 47
```
출력
```
41
```

### 예제 설명
예제에서 `t`는 3이고 `h`는 50이다. <br>
각 구간의 드론 고도 비용은 다음과 같다.

|index|array|calc|cost|
|-----|-----|----|----|
|0 ~ 2|[90, 61, 36]| \|90 - 50\| + \|61 - 50\| + \|36 - 50\| | 65|
|1 ~ 3|[61, 36, 72]| \|61 - 50\| + \|36 - 50\| + \|72 - 50\| | 47|
|2 ~ 4|[36, 72, 55]| \|36 - 50\| + \|72 - 50\| + \|55 - 50\| | 41|
|3 ~ 5|[72, 55, 90]| \|72 - 50\| + \|55 - 50\| + \|90 - 50\| | 67|
|4 ~ 6|[55, 90, 15]| \|55 - 50\| + \|90 - 50\| + \|15 - 50\| | 80|
|5 ~ 7|[90, 15, 47]| \|90 - 50\| + \|15 - 50\| + \|47 - 50\| | 78|

따라서 드론 고도 비용의 최소값은 `[36, 72, 55]`에서의 `41`이다.

### 풀이법 1
```python
n, h, t = map(int, input().split())
arr = list(map(int, input().split()))
ans = float('inf')

for i in range(n-t+1):
    tmp = arr[i:i+t]
    sum_val = 0
    for j in tmp:
        sum_val += abs(j-h)
    ans = min(ans, sum_val)

print(ans)
```

1. 인덱스 `i`부터 `i+t-1`까지 구간 설정. 시작 인덱스는 `0 ~ n - t`
2. 설정한 구간에서 각각의 고도에 목표 고도 `h`의 오차의 총합을 구한다. `|j - h|`
3. 최솟값을 갱신한다.

### 풀이법 2
```python
n, h, t = map(int, input().split())
arr = list(map(int, input().split()))
ans = sum_val = sum(abs(arr[i] - h) for i in range(t))

for i in range(1, n-t+1):
    sum_val -= abs(arr[i - 1] - h) - abs(arr[i + t - 1] - h)
    ans = min(sum_val, ans)

print(ans)
```

1. `sum_val` : 초기 구간 (`0 ~ t - 1`)의 오차의 총합
2. `ans` : 현재까지의 최소 오차
3. 슬라이딩 윈도우로 구간을 이동하며 오차의 최솟값을 구한다.
  - 길이 `t`의 연속된 구간을 하나씩 밀며 찾는다.
  - 이전 구간의 첫 번째 값을 제거하고 새로운 값을 추가하여 오차를 계산.

## 풀이법 비교
### 풀이법 1
- 모든 가능한 길이 `t`의 구간을 슬라이싱하여 확인 (Brute Force)
- 각 구간에 대해 `|arr[j] - h|`를 매번 더해 오차 합을 구한다.
- 바깥 반복문은 <code>O(n)</code>, 안쪽 반복문은 <code>O(t)</code>가 걸리므로 총 <code>O(n x t)</code> 시간이 걸린다.

### 풀이법 2
- 첫 구간의 오차 총합을 구하고 이후 맨 앞의 값을 빼고 추가된 값을 더해 구간을 한 칸씩 밀며 오차를 갱신한다.
- <code>O(n)</code> 시간이 걸린다.
