---
layout: single
title: "파이썬 - 오목 찾기"
categories: coding
tag: [알고리즘, 코딩테스트, 수학, 조합, Python]
toc: true
author_profile: false
sidebar:
  nav: "docs"
---

## 문제
19x19 크기의 바둑판이 주어진다. 각 칸에는 0, 1, 2가 주어지며, **0은 빈 칸, 1은 흑, 2는 백**을 나타낸다. <br>
바둑판 위에서 **첫 번째**로 오목이 성립하는 경우를 찾아 그 오목의 **색과 좌표**를 출력하라. <br>
좌표는 1부터 시작한다.

오목은 **가로, 세로, 또는 대각선 방향**으로 **연속된 5개**의 돌이 있는 경우를 말한다.

### 입력 형식
첫 번째 줄부터 19번째 줄에 걸쳐 바둑판 상태가 주어진다. <br>
각 줄은 19개의 정수로 이루어져 있으며, 각 숫자는 0, 1, 2 중 하나이다.

### 출력 형식
첫 번째로 발견된 오목의 돌의 색(black 또는 white)과 그 오목의 5개의 좌표를 출력한다.<br>
오목을 이루는 5개의 좌표를 출력해야 하며, 좌표는 가로 또는 세로, 대각선 순으로 출력한다.


### 입출력 예제
입력
```
1 0 0 2 0 2 1 0 1 1 2 1 2 0 1 0 2 0 0
2 1 1 1 1 0 0 0 2 0 2 0 2 2 1 0 1 1 2
1 2 1 1 0 0 1 0 0 0 2 2 2 1 2 1 1 0 2
2 2 2 0 1 0 2 1 2 2 0 1 0 1 1 2 2 0 0
2 0 1 0 2 0 2 2 0 2 0 2 0 2 2 1 1 1 0
0 1 0 0 1 1 0 0 2 2 1 2 1 2 0 0 0 1 0
1 2 1 1 1 0 2 1 2 2 0 2 1 1 0 0 2 2 2
2 0 1 2 1 1 1 0 1 1 2 2 2 2 0 2 2 0 1
2 2 1 2 0 0 2 1 2 0 1 1 0 1 1 1 2 2 1
2 0 1 2 0 1 1 2 2 0 1 1 1 1 0 1 1 0 0
0 0 2 2 1 0 2 0 2 0 0 1 0 0 2 2 0 1 0
1 1 2 2 0 0 1 1 0 0 2 1 1 2 0 0 1 2 2
2 1 1 0 1 0 1 2 0 0 0 0 0 1 0 1 1 1 1
0 1 1 2 0 0 2 0 2 0 2 1 2 2 0 2 0 0 0
1 0 2 0 1 1 1 2 0 2 0 0 1 2 1 0 1 1 1
0 2 0 1 0 2 1 0 0 1 1 1 0 2 0 1 0 1 0
2 2 2 1 1 1 2 0 1 2 2 2 1 2 0 2 2 0 1
1 2 1 1 2 0 1 0 0 0 1 0 0 0 1 2 0 1 2
0 0 0 0 1 2 2 0 0 2 1 1 0 2 1 1 0 1 2 
```
출력
```
white
(4, 7) (5, 8) (6, 9) (7, 10) (8, 11)
```

### 예제 설명
입력 예제에서 `4`행 `7`열에 2가 있다. 그 좌표를 기준으로 오른쪽 하단 대각선 방향으로 2가 4개가 추가로 있다. <br>
따라서 오목이 성립되고 2는 백돌이므로 `white`를 출력한다.<br> 
그리고 오목이 성립되는 좌표 `(4, 7) (5, 8) (6, 9) (7, 10) (8, 11)`를 출력한다.

또한 `8`행 `4`열에 2가 있고 아래 방향으로 2가 4개가 추가로 있어 오목이 성립된다. <br>
하지만 `8`행 `4`열 위에 `4`행 `7`열에서 오목이 이미 성립되어 이는 건너뛴다.

## 풀이법 1
```python
board = [list(map(int, input().split())) for _ in range(19)]

isfind = False
for i in range(19):
    for j in range(19):
        if board[i][j] != 0:
            num = board[i][j]
            
            for dx, dy in [(1, 0), (0, 1), (1, 1), (1, -1)]:
                if 0 <= (i + dx * 4) < 19 and 0 <= (j + dy * 4) < 19:
                    isfive = True
                    
                    for k in range(1, 5):
                        if not num == board[i + dx * k][j + dy * k]:
                            isfive = False
                            break
                    
                    if isfive:
                        if num == 1:
                            print('black')
                        else:
                            print('white')

                        for k in range(5):
                            print((i + 1 + dx * k, j + 1 + dy * k), end=' ')

                        isfind = True
                        break
        
        if isfind:
            break
    
    if isfind:
        break

if not isfind:
    print(0)

```

1. `isfind`은 오목이 발견되었는지 여부를 나타낸다.
2. 바둑판의 모든 좌표 (19x19)를 탐색해야 하므로 2중 반복문을 사용한다.
3. 현재 위치가 0이 아니라면 돌이 있는 경우이므로 오목이 될 가능성이 있는지 확인한다.
4. 4가지 방향 (가로 (→), 세로 (↓), 대각선 (↘),  대각선 (↙))으로 연속된 5개의 돌이 있는지 탐색한다.
  - 가로 (←) 왼쪽 방향은 탐색을 안해도 될까?
  - 오목은 5개가 연속으로 연결되어 있는지만 확인하면 되니까 반대 방향을 추가로 탐색할 필요가 없다.
  - 이와 같이 위의 4가지 방향의 반대 방향까지 탐색하면 중복이 되므로 4방향만 탐색한다.
5. 5개의 돌이 연속으로 놓여야 하므로, 마지막 돌의 위치가 바둑판 범위 안에 있는지 확인한다.
6. `isfive`는 연속된 5개의 돌이 있는지 여부를 나타낸다.
7. 만약 중간에 다른 돌이 있거나 돌이 없으면 중단하고 다른 돌을 탐색한다.
8. 오목이 성립되었다면 해당 돌이 흑돌인지 백돌인지 출력한다.
9. 그리고 오목을 이루는 5개의 좌표를 출력한다.
10. 첫 번째 발견된 오목만 출력하므로 오목을 찾으면 반복문을 중단하여 탈출한다.
11. 만약 `isfind`가 `False`이면 바둑판 전체를 탐색했는데 오목을 찾지 못한 경우이므로 `0`을 출력한다.
