---
layout: single
title: "파이썬 - 효율적인 업무 처리"
categories: coding
tag: [Python, 알고리즘, 코딩테스트, 누적 합, 이분탐색]
toc: true
author_profile: false
sidebar:
  nav: "docs"
---

## 문제
당신은 `N`개의 프로젝트 업무를 할당받았다. 각 업무는 크게 <b>코딩 작업 시간</b>과 <b>문서화 시간</b>으로 구성된다. <br>
총 `T`시간이라는 제한된 작업 시간 내에 <b>최대한 많은 업무</b>를 완료하려고 한다.

흥미로운 점은, 당신이 가진 특별한 자동화 도구를 사용하면 오직 <b>하나의 업무</b>에 대해서만 <b>코딩 작업 시간</b>을 <b>절반</b>으로 줄일 수 있다는 것이다. <br>
문서화 시간은 자동화 도구의 영향을 받지 않으며, 항상 원래 시간을 <b>모두 소요</b>해야 한다.

주어진 총 작업 시간 `T`내에서 자동화 도구를 최적으로 활용하여 완료할 수 있는 업무의 최대 개수를 구하라.

### 입력 형식
첫째 줄에 총 업무의 개수 `N`과 총 작업 시간 `T`가 공백으로 구분하여 주어진다. <br>
다음 `N`개의 줄에는 각 업무의 코딩 작업 시간 `T_code`와 문서화 시간 `T_doc`이 공백으로 구분하여 주어진다. (단, T_code는 항상 짝수이다.)

### 출력 형식
첫째 줄에 최대로 완료할 수 있는 업무의 개수를 출력한다.

### 입출력 예제
입력
```
7 28
6 2
4 3
10 1
2 5
8 3
12 4
6 3
```
출력
```
4
```

### 예제 설명
총 업무의 개수는 7개이고 총 작업 시간은 28이다. 각 업무의 코딩 작업 시간과 문서화 시간은 다음과 같다.

|number|T_code|T_doc|T_sum|
|------|------|-----|-----|
|1|6|2|8|
|2|4|3|7|
|3|10|1|11|
|4|2|5|7|
|5|8|3|11|
|6|12|4|16|
|7|6|3|9|

이 때, 각 업무에 자동화 도구를 사용한 전체 시간은 다음과 같다.

|number|T_code|T_doc|T_sum|T_sum(discount)|
|------|------|-----|-----|---------------|
|1|6|2|8|6 // 2 + 2 = 5|
|2|4|3|7|4 // 2 + 3 = 5|
|3|10|1|11|10 // 2 + 1 = 6|
|4|2|5|7|2 // 2 + 5 = 6|
|5|8|3|11|8 // 2 + 3 = 7|
|6|12|4|16|12 // 2 + 4 = 10|
|7|6|3|9|6 // 2 + 3 = 6|

각 업무에 자동화 도구를 사용한 후 작업 시간 내에 완료할 수 있는 업무의 최대 개수는 다음과 같다.

|number|tasks|max_count|
|------|-----|---------|
|1|5 (1번 업무 자동화) + 7(2번 업무) + 7(4번 업무) + 9(7번 업무) = 28|4|
|2|5 (2번 업무 자동화) + 7(4번 업무) + 8(1번 업무) = 20|3|
|3|6 (3번 업무 자동화) + 7(2번 업무) + 7(4번 업무) + 8(1번 업무) = 28|4|
|4|6 (4번 업무 자동화) + 7(2번 업무) + 8(1번 업무) = 21|3|
|5|7 (5번 업무 자동화) + 7(2번 업무) + 7(4번 업무) = 21|3|
|6|10 (6번 업무 자동화) + 7(2번 업무) + 7(4번 업무) = 24|3|
|7|6 (7번 업무 자동화) + 7(2번 업무) + 7(4번 업무) + 8(1번 업무) = 28|4|

따라서 1, 3, 7번을 자동화 도구를 사용하면 작업 시간 내에 마칠 수 있는 업무의 최대 개수는 4개이다.

### 풀이법 1
```python
n, t = map(int, input().split())
tasks_data = [tuple(map(int, input().split())) for _ in range(n)]

ans = 0
tasks_costs = [tasks_data[j][0] + tasks_data[j][1] for j in range(n)]

for i in range(n):
    data = tasks_costs[i]
    tasks_costs[i] = tasks_data[i][0] // 2 + tasks_data[i][1]

    sort_tasks_costs = sorted(tasks_costs)
    curr_time = 0
    for j in range(n):
        curr_time += sort_tasks_costs[j]
        if curr_time > t:
            break
    ans = max(ans, j)
    tasks_costs[i] = data

print(ans)
```
1. 변수 초기화 및 데이터 로드
- `tasks_data` : 각 업무의 코딩 작업 시간과 문서화 시간 정보를 담고 있는 리스트
- `ans` : 최대로 완료할 수 있는 업무의 개수
- `tasks_costs` : 각 업무에 자동화 도구를 사용하지 않는 총 소요 시간을 계산
2. 각 업무에 자동화 도구 사용
- `data` : `i`번째 업무의 원래 소요 시간. 나중에 값을 원상 복구하기 위해 사용
- `i`번째 업무에 자동화 도구를 사용하여 코딩 시간을 절반으로 줄인다.
- `sort_tasks_costs` : 자동화 도구를 사용 후 리스트를 오름차순으로 정렬.
  - 소요 시간이 가장 짧은 업무부터 처리하여 총 작업 시간 내에 최대한 많은 업무를 완료하기 위해 정렬.
3. 총 작업 시간 내 업무 처리 개수 계산
- `curr_time` : 현재까지 완료한 업무들의 총 소요 시간을 누적
- `j`번째 업무 소요 시간을 `curr_time`에 더한다.
- 총 작업 시간 `t`를 초과하면 반복문을 중단한다.
- 이 때, `j`는 이전에 완료한 업무의 개수를 나타낸다.
  - `j`가 0에서 반복문 중단 -> 0개 업무 처리
  - `j`가 3에서 반복문 중단 -> 3개 업무 처리
- `j`를 현재까지의 최대 완료 개수인 `ans`와 비교하여 더 큰 값으로 갱신한다.

- `i`번째 업무에 대한 시뮬레이션이 끝났으므로 `tasks_costs[i]`를 `data`로 되돌린다.

<code>O(n<sup>2</sup>logn)</code>

### 풀이법 2 (누적합, 이분탐색)
```python
import bisect

n, t = map(int, input().split())
tasks_data = []

for _ in range(n):
    T_code, T_doc = map(int, input().split())
    tasks_data.append((T_code + T_doc, T_code // 2 + T_doc))

tasks_data.sort()

prefix_costs = [0] * (n + 1)
for i in range(n):
    prefix_costs[i + 1] = prefix_costs[i] + tasks_data[i][0]

ans = bisect.bisect_right(prefix_costs, t) - 1
cost = prefix_costs[ans]

for i in range(ans, n):
    if tasks_data[i][1] + cost <= b:
        ans += 1
        break

print(ans)
```

1. 변수 초기화 및 데이터 로드
- `tasks_data` : 원래 소요 시간과 자동화 도구를 사용 시 소요 시간을 튜플 형태로 리스트에 추가한다.
- 원래 소요 시간을 기준으로 오름차순 정렬한다.
  - `bisect`를 사용하기 위해
2. 누적 합 계산
- 정렬된 `tasks_data`의 원래 소요 시간에 대한 누적 합을 저장한다.
- `prefix_costs[k]`는 `tasks_data`의 첫 `k`개 업무를 원래 소요 시간의 총 시간을 나타낸다.
3. 이진 탐색으로 초기 시간 및 개수 계산
- `ans` (최대 업무 개수)
  - `prefix_costs`에서 총 작업 시간보다 큰 첫 번째 요소가 삽입될 수 있는 인덱스를 반환한다.
  - 이는 총 작업 시간 내에 완료할 수 있는 업무 개수보다 1개 큰 인덱스를 가리킨다.
  - 따라서 `-1`을 하여 총 작업 시간 내에 할인 없이 완료 가능한 최대 업무 개수를 저장한다.
- `cost` : `ans` 개수만큼 완료하는 데 소요되는 총 소요 시간
4. 자동화 도구를 사용한 추가 업무 개수 탐색
- 반복문을 통해 `ans` 개의 업무를 원래 소요 시간에서 추가로 한 개의 업무를 자동화 도구를 사용하여 총 작업 시간 내에 완료할 수 있는지를 확인한다.
- `ans`부터 `n-1`까지 순회한다.
  - 이미 `ans`개까지는 원래 업무 시간을 사용할 수 있다.
  - 따라서 그 이후의 업무들 중 자동화 도구를 사용할 수 있는지를 판단한다.
- `tasks_data[i]`번째 업무를 자동화 도구를 사용하여 추가했을 때 총 작업 시간을 초과하지 않는지 확인한다.
- 조건이 충족되면 업무를 추가할 수 있으므로 `ans`를 1 증가하고 반복문을 종료한다.
  - 하나의 업무에만 자동화 도구를 사용할 수 있다는 조건 때문이다.
 
<code>O(nlogn)</code>
