---
layout: single
title: "파이썬 - 물류 센터 최적 위치 찾기"
categories: coding
tag: [알고리즘, 코딩테스트, 누적 합, Python]
toc: true
author_profile: false
sidebar:
  nav: "docs"
---

## 문제
한 도시에는 n 개의 상점이 일렬로 배치되어 있으며, 각 상점에는 특정 개수의 물건이 보관되어 있습니다. 이 도시는 **새로운 물류 센터**를 하나 세우려고 합니다.

물류 센터는 한 상점의 위치에 세울 수 있으며, 모든 물건을 물류 센터로 옮기는 데 드는 총 이동 거리를 최소화하려고 합니다. 물건은 상점에서 물류 센터까지의 인덱스 차이만큼의 거리를 이동해야 합니다.

각 상점에서 물류 센터까지의 이동 거리 총합이 최소가 되는 경우를 찾아, 그 최소 이동 거리를 출력하는 프로그램을 작성하세요.

### 입력 형식
첫 번째 줄에 정수 n이 주어집니다. 이는 상점의 개수를 나타냅니다.<br>
두 번째 줄에 길이 n 의 정수 배열이 주어집니다. <br>
i번째 정수는 i번째 상점에 보관된 물건의 개수를 나타냅니다.

### 출력 형식
모든 물건이 한 곳의 물류 센터로 옮겨질 때 이동 거리 총합의 최소값을 출력합니다.

### 입출력 예제
입력
```
6
1 5 9 3 7 5
```
출력
```
39
```

### 예제 설명
각 상점에 물류 센터를 세웠을 때 이동 거리 합을 계산하면
<ul>
  <li>1번 상점에서 물류 센터를 세우면 (0 × 1) + (1 × 5) + (2 × 9) + (3 × 3) + (4 × 7) + (5 × 5) = 85 </li>
  <li>2번 상점에서 물류 센터를 세우면 (1 × 1) + (0 × 5) + (1 × 9) + (2 × 3) + (3 × 7) + (4 × 5) = 57 </li>
  <li>3번 상점에서 물류 센터를 세우면 (2 × 1) + (1 × 5) + (0 × 9) + (1 × 3) + (2 × 7) + (3 × 5) = 39 </li>
  <li>4번 상점에서 물류 센터를 세우면 (3 × 1) + (2 × 5) + (1 × 9) + (0 × 3) + (1 × 7) + (2 × 5) = 39 </li>
  <li>5번 상점에서 물류 센터를 세우면 (4 × 1) + (3 × 5) + (2 × 9) + (1 × 3) + (0 × 7) + (1 × 5) = 45 </li>
  <li>6번 상점에서 물류 센터를 세우면 (5 × 1) + (4 × 5) + (3 × 9) + (2 × 3) + (1 × 7) + (0 × 5) = 65 </li>
</ul>
따라서 이동 거리 총합이 최소가 되는 경우는 3번 또는 4번 상점에서 물류 센터를 세울 때이며, 결과는 39이다.

## 풀이법 1
```python
import sys

n = int(input())
A = list(map(int, input().split()))

ans = sys.maxsize
for i in range(n):
  sum_dist = 0
  for j in range(n):
    sum_dist += abs(i-j) * A[j]
  
  ans = min(ans, sum_dist)

print(ans)
```
1. 최소값을 구하기 위해 최댓값으로 초기화한다.
2. 각 `j`에서 `i`까지의 거리 `abs(i-j)`에 `A[j]`(그 위치에 있는 물건 개수)를 곱하여 이동 비용을 계산한다.
3. `i`를 기준으로 모일 때 총 이동 거리 `sum_dist`를 계산한다.
4. 최소 `sum_dist` 값을 찾아 `ans`에 저장.

위 코드를 간단하게 하면 다음과 같다.
```python
import sys

n = int(input())
A = list(map(int, input().split()))

ans = sys.maxsize
ans = min(sum(abs(i-j) * A[j] for j in range(n)) for i in range(n))

print(ans)
```

## 풀이법 2
```python
n = int(input())
A = list(map(int, input().split()))

sum_A = sum(A)
ans = dist_sum = sum(val * idx for idx, val in enumerate(A))
prefix_sum = 0

for i in range(n-1):
    prefix_sum += A[i]
    dist_sum -= sum_A - 2 * prefix_sum
    ans = min(ans, dist_sum)
print(ans)
```

### 아이디어
리스트 A에는 다음과 같이 있다.
```
A = [a1, a2, a3, a4, a5, a6]
```
1번, 2번 상점에 물류 센터를 세울 때때 거리 합은 다음과 같다.
<ul>
  <li>1번 상점에서 물류 센터를 세우면 (0 × a1) + (1 × a2) + (2 × a3) + (3 × a4) + (4 × a5) + (5 × a6) 이다. </li>
  <li>2번 상점에서 물류 센터를 세우면 (1 × a1) + (0 × a2) + (1 × a3) + (2 × a4) + (3 × a5) + (4 × a6) 이다. </li>
</ul>

각각의 최소 거리의 합을 `num1`, `num2`라 하자. <br>
이 때 `num1`에서 `num2`을 빼면 다음과 같다. <br>

```
num1 - num2 = a2 + a3 + a4 + a5 + a6 - (a1)
```

여기서 num2는 다음과 같이 구할 수 있다.
```
num2 = num1 - (a2 + a3 + a4 + a5 + a6 - (a1))
```
2번, 3번 상점에 물류 센터를 세워 거리 합을 빼면 다음과 같다.

```
# num2 : 2번 상점에서의 거리 합
# num3 : 3번 상점에서의 거리 합
num2 - num3 = a3 + a4 + a5 + a6 - (a1 + a2)
```
여기서 num3는 다음과 같이 구할 수 있다.

```
num3 = num2 - (a3 + a4 + a5 + a6 - (a1 + a2))
```

따라서 k번 상점에 물류 센터를 세운 후 거리의 합을 구하는 방법은 <br>
**((k-1)번 상점에 물류 센터를 세훈 후 거리 합) - ((ak부터 an까지의 합) - (a1부터 ak-1까지의 합))** 이다.

이 때 `A` 리스트 원소의 합을 `sum_A` 라 하자.

다시 정리하면 다음과 같다.

**((k-1)번 상점에 물류 센터를 세훈 후 거리 합) - (sum_A - 2 * (a1부터 ak-1까지의 합))** 이다.

### 풀이법 2 코드 분석

1. `sum_A` : 배열 전체 합 (물건 수의 합)
2. `ans`, `dist_sum` : 초기 이동 거리. 0번 상점에 물류 센터를 세운 후 거리 합
3. `prefix_sum` : a1부터 ak-1까지 누적합
4. n개의 거리 합을 구해야 하므로 초기 값을 제외한 n-1개를 반복문으로 해결
5. `dist_sum - sum_A - 2 * prefix_sum`을 통해 `i-1`번째의 거리 합으로 `i`번째 거리 합 계산
6. 최소 거리 합을 `ans`에 할당

